
# Web3 å¼€å‘å­¦ä¹ ä»»åŠ¡
## ğŸ¯ å­¦ä¹ ç›®æ ‡
1. æŒæ¡ä»¥å¤ªåŠ JSON-RPC è§„èŒƒ
2. ç†Ÿç»ƒä½¿ç”¨ ethers.js æ ¸å¿ƒåŠŸèƒ½
3. å®ç°å®Œæ•´ DApp å¼€å‘æµç¨‹
4. ç†è§£æ™ºèƒ½åˆçº¦äº¤äº’åŸç†
## ğŸ“š åŸºç¡€å­¦ä¹ æ¨¡å—
```bash
# 1. ç¯å¢ƒæ­å»º
npm install ethers hardhat @nomiclabs/hardhat-waffle
 ```

å®æˆ˜ä»»åŠ¡ 1ï¼šè¿æ¥é’±åŒ…
import { ethers } from 'ethers'

// åˆ›å»ºé’±åŒ…å®ä¾‹
const createWallet = () => {
  const wallet = ethers.Wallet.createRandom()
  return {
    address: wallet.address,
    privateKey: wallet.privateKey,
    mnemonic: wallet.mnemonic.phrase
  }
}

// è¿æ¥ MetaMask
const connectMetaMask = async () => {
  const provider = new ethers.providers.Web3Provider(window.ethereum)
  await provider.send("eth_requestAccounts", [])
  return provider.getSigner()
}


ğŸ”¥ æ ¸å¿ƒå®æˆ˜ä»»åŠ¡
ä»»åŠ¡ 2ï¼šä»£å¸è½¬è´¦
const transferERC20 = async (
  contractAddress: string,
  to: string,
  amount: string
) => {
  const provider = new ethers.providers.Web3Provider(window.ethereum)
  const signer = provider.getSigner()
  const contract = new ethers.Contract(
    contractAddress,
    ERC20_ABI,
    signer
  )
  
  const tx = await contract.transfer(to, ethers.utils.parseUnits(amount, 18))
  return tx.wait()
}
 
ä»»åŠ¡ 3ï¼šç›‘å¬é“¾ä¸Šäº‹ä»¶
const monitorTransfers = (contractAddress: string) => {
  const provider = ethers.getDefaultProvider('mainnet')
  const contract = new ethers.Contract(contractAddress, ERC20_ABI, provider)
  
  contract.on('Transfer', (from, to, value, event) => {
    console.log(`Transfer: ${value} from ${from} to ${to}`)
  })
}
 
ğŸ› ï¸ ç»¼åˆé¡¹ç›®
å»ä¸­å¿ƒåŒ–äº¤æ˜“æ‰€ï¼ˆDEXï¼‰åŠŸèƒ½éœ€æ±‚
const swapTokens = async (
  routerAddress: string,
  path: string[],
  amountIn: string
) => {
  const provider = new ethers.providers.Web3Provider(window.ethereum)
  const signer = provider.getSigner()
  
  const router = new ethers.Contract(
    routerAddress,
    UNISWAP_ROUTER_ABI,
    signer
  )

  const deadline = Math.floor(Date.now() / 1000) + 60 * 20 // 20åˆ†é’Ÿæœ‰æ•ˆæœŸ
  const tx = await router.swapExactTokensForTokens(
    ethers.utils.parseUnits(amountIn, 18),
    0, // æœ€å°è¾“å‡ºé‡
    path,
    await signer.getAddress(),
    deadline
  )

  return tx.wait()
}


ğŸ“Š å­¦ä¹ è·¯çº¿å›¾
graph TD
    A[ç¯å¢ƒæ­å»º] --> B[é’±åŒ…äº¤äº’]
    B --> C[åˆçº¦å¼€å‘]
    C --> D[äº‹ä»¶ç›‘å¬]
    D --> E[DeFiåè®®é›†æˆ]
    E --> F[å®‰å…¨å®¡è®¡]

ğŸ’¡ æ‰©å±•å†…å®¹
1.æ™ºèƒ½åˆçº¦å¼€å‘ ï¼šä½¿ç”¨ Hardhat ç¼–å†™æµ‹è¯•ç”¨ä¾‹
describe("ERC20 Token", function () {
  it("Should deploy with initial supply", async function () {
    const Token = await ethers.getContractFactory("MyToken")
    const token = await Token.deploy(ethers.utils.parseUnits("1000000", 18))
    
    const totalSupply = await token.totalSupply()
    expect(totalSupply).to.equal(ethers.utils.parseUnits("1000000", 18))
  })
})

2.NFT åŠŸèƒ½å¼€å‘
// ERC721 åˆçº¦ç¤ºä¾‹
contract MyNFT is ERC721 {
    constructor() ERC721("MyNFT", "MNFT") {
        _mint(msg.sender, 1);
    }
}
